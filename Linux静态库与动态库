#Linux下的静态库.a结尾(Winodws下为.lib)
    (1).首先使用 gcc 命令把源文件编译为目标文件，即.o文件
    #创建.o目标文件
    gcc -c 源文件列表  
    #-c选项表示只编译，不链接
    gcc -c test.c -o libtest.o
    (2).然后使用 ar 命令将.o文件打包成静态链接库，具体格式为：                               
    ar rcs + 静态库文件的名字 + 目标文件列表
    #创建libtest.a静态库
    ar rcs libtest.a libtest1.o  libtest2.o
    #链接静态库
    gcc -o test main.c -ltest

#Linux下的动态库.so结尾或.so.y结尾，其中y代表版本号(Windows下为.dll)，而且，Linux下的库必须以lib开头，用于系统识别(如：libjpeg.a libsdl.so)
    # 使用位置无关代码创建目标文件
    gcc -c -fPIC test.c -o test.o
    # 创建共享库libtest.so
    gcc -shared -o libtest.so test.o
    # 链接静态库
    gcc -o test main.c -ltest
在比较规范的项目目录中:
  lib 文件夹一般用来存放库文件，
  include 文件夹一般用来存放头文件，
  src 文件夹一般用来存放源文件，
  bin 文件夹一般用来存放可执行文件。
#静态库必要的目标代码的是在对程序编译的时候被加入到程序中,而运行时不再需要.a的库了。
而动态库，则是在运行时转载。所以，动态链接的可执行代码比静态链接的可执行代码小的多.
静态库是牺牲了空间效率，换取了时间效率.
共享库是牺牲了时间效率换取了空间效率
linux储存位置：静态库的保存位置和共享库是一样的 /lib（系统启动时需要的库，执行shell需要的库，是系统最关键的库） /usr/lib（开发时用到的库）

加载时间不同：静态库在静态链接时使用，每个程序都有一份 共享库在动态链接时使用。
所以使用静态库的缺点是：
1.在多进程操作系统下浪费内存和磁盘空间。
2.修改静态库后，需要重新链接。
3.共享库就是为了解决静态库的这些缺点：节省内存，减少物理页面的换入换出，增加cpu的缓存命中率。

动态库分为显式调用和隐式调用
1.显示调用
2.隐式调用

生成静态库和共享库的命令：
ar:
选项前可以有'-'字符，也可以没有
r：在库中插入模块(替换)。
c：创建一个库。不管库是否存在，都将创建。
s：创建目标文件索引，在创建较大的库时能提高速度。
v：该选项用来显示执行操作选项的附加信息

GCC生成和使用静态链接库
#http://c.biancheng.net/view/7168.html
静态库：
首先将源文件编译成目标文件：gcc –c a.c b.c
生成静态库：ar crv libstatic.a a.o b.o

共享库：
同静态库一样编译成目标文件：gcc –c a.c b.c
生成共享库：gcc –fPIC –shared –o libshared.so a.o b.o

-shared 产生共享对象
-fPIC 使用地址无关技术（如果没有这命令选项，产生的将是装载时重定位对象）

/proc/pid/maps
内存段虚拟地址执行权限进程地址里偏移量映射文件的主设备号和次设备号（cat /proc/devices）映像文件路径

readeld –l Lib.so
判断一个DSO是否为PIC的办法
readelf –d foo.so | greap TEXTREL（重定位表地址）
有信息就表示有重定位表，那么就不是PIC

库文件：一组编译好的函数集合
ld-2.6.so 动态链接器
linux命名共享库的规则：libname.so.x.y.z
1. 前缀"lib"+ 自定义名字"name"+ 后缀"so"
2. x：主版本号 y：次版本号 z：发布版本号
3. glibc不遵守规则，使用 libc-x.y.z.so

ldconfig更新共享库
静态库使用静态链接
共享库使用动态链接

动态链接：
就是把链接的过程推迟到了运行的时候
在链接的时候，共享库也作为链接的输入文件之一，
符号解析的时候，把源文件中重定位推迟到运行程序的时候
装载时重定位程序运行时，共享库模块地址确定，系统对程序中所有的绝对地址进行重定位

优化动态链接性能：
地址无关代码：把指令中需要修改的部分分离出来，和数据部分放一起，内存就不会有多份指令的拷贝了，因为指令都一样
延迟绑定：当函数第一次被用到才进行绑定
