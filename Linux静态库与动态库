#Linux下的静态库.a结尾(Winodws下为.lib)
    (1).首先使用 gcc 命令把源文件编译为目标文件，即.o文件
    #创建.o目标文件
    gcc -c 源文件列表  
    #-c选项表示只编译，不链接
    gcc -c test.c -o libtest.o
    (2).然后使用 ar 命令将.o文件打包成静态链接库，具体格式为：                               
    ar rcs + 静态库文件的名字 + 目标文件列表
    #创建libtest.a静态库
    ar rcs libtest.a libtest1.o  libtest2.o
    #链接静态库
    gcc -o test main.c -ltest
#Linux 下动态链接库（shared object file，共享对象文件）的文件后缀为.so，它是一种特殊的目标文件（object file），可以在程序运行时被加载（链接）进来。
#使用动态链接库的优点：程序的可执行文件更小，便于程序的模块化以及更新，同时，有效内存的使用效率更高。
#Linux下的动态库.so结尾或.so.y结尾，其中y代表版本号(Windows下为.dll)，而且，Linux下的库必须以lib开头，用于系统识别(如：libjpeg.a libsdl.so)
    # 使用位置无关代码创建目标文件
    gcc -c -fPIC test.c -o test.o
    # 创建共享库libtest.so
    gcc -shared -o libtest.so test.o
    # 链接静态库
    gcc -o test main.c -ltest
    
    
在比较规范的项目目录中:
  lib 文件夹一般用来存放库文件，
  include 文件夹一般用来存放头文件，
  src 文件夹一般用来存放源文件，
  bin 文件夹一般用来存放可执行文件。
#静态库必要的目标代码的是在对程序编译的时候被加入到程序中,而运行时不再需要.a的库了。
而动态库，则是在运行时转载。所以，动态链接的可执行代码比静态链接的可执行代码小的多.
静态库是牺牲了空间效率，换取了时间效率.
共享库是牺牲了时间效率换取了空间效率
linux储存位置：静态库的保存位置和共享库是一样的 /lib（系统启动时需要的库，执行shell需要的库，是系统最关键的库） /usr/lib（开发时用到的库）

加载时间不同：静态库在静态链接时使用，每个程序都有一份 共享库在动态链接时使用。
所以使用静态库的缺点是：
1.在多进程操作系统下浪费内存和磁盘空间。
2.修改静态库后，需要重新链接。
3.共享库就是为了解决静态库的这些缺点：节省内存，减少物理页面的换入换出，增加cpu的缓存命中率。

动态库分为显式调用和隐式调用
1.显示调用
2.隐式调用

生成静态库和共享库的命令：
ar:
选项前可以有'-'字符，也可以没有
r：在库中插入模块(替换)。
c：创建一个库。不管库是否存在，都将创建。
s：创建目标文件索引，在创建较大的库时能提高速度。
v：该选项用来显示执行操作选项的附加信息

GCC生成和使用静态链接库
#http://c.biancheng.net/view/7168.html
静态库：
首先将源文件编译成目标文件：gcc –c a.c b.c
生成静态库：ar crv libstatic.a a.o b.o

GCC生成和使用动态链接库
http://c.biancheng.net/view/2385.html
如果想创建一个动态链接库，可以使用 GCC 的-shared选项。输入文件可以是源文件、汇编文件或者目标文件。
另外还得结合-fPIC选项。-fPIC 选项作用于编译阶段，告诉编译器产生与位置无关代码（Position-Independent Code）；
这样一来，产生的代码中就没有绝对地址了，全部使用相对地址，所以代码可以被加载器加载到内存的任意位置，都可以正确的执行。
这正是共享库所要求的，共享库被加载时，在内存的位置不是固定的。

从源文件生成动态链接库：
$ gcc -fPIC -shared func.c -o libfunc.so

从目标文件生成动态链接库：
$ gcc -fPIC -c func.c -o func.o
$ gcc -shared func.o -o libfunc.so

-fPIC 选项作用于编译阶段，在生成目标文件时就得使用该选项，以生成位置无关的代码。
GCC 将动态链接库链接到可执行文件
如果希望将一个动态链接库链接到可执行文件，那么需要在命令行中列出动态链接库的名称，具体方式和普通的源文件、目标文件一样。
$ gcc main.c libfunc.so -o app.out

将 main.c 和 libfunc.so 一起编译成 app.out，当 app.out 运行时，会动态地加载链接库 libfunc.so。
当然，必须要确保程序在运行时可以找到这个动态链接库。你可以将链接库放到标准目录下，例如 /usr/lib，或者设置一个合适的环境变量，例如 LIBRARY_PATH。不同系统，具有不同的加载链接库的方法。

共享库：
同静态库一样编译成目标文件：gcc –c a.c b.c
生成共享库：gcc –fPIC –shared –o libshared.so a.o b.o

-shared 产生共享对象
-fPIC 使用地址无关技术（如果没有这命令选项，产生的将是装载时重定位对象）
/proc/pid/maps
内存段虚拟地址执行权限进程地址里偏移量映射文件的主设备号和次设备号（cat /proc/devices）映像文件路径

readeld –l Lib.so
判断一个DSO是否为PIC的办法
readelf –d foo.so | greap TEXTREL（重定位表地址）
有信息就表示有重定位表，那么就不是PIC

库文件：一组编译好的函数集合
ld-2.6.so 动态链接器
linux命名共享库的规则：libname.so.x.y.z
1. 前缀"lib"+ 自定义名字"name"+ 后缀"so"
2. x：主版本号 y：次版本号 z：发布版本号
3. glibc不遵守规则，使用 libc-x.y.z.so

ldconfig更新共享库
静态库使用静态链接
共享库使用动态链接

动态链接：
就是把链接的过程推迟到了运行的时候
在链接的时候，共享库也作为链接的输入文件之一，
符号解析的时候，把源文件中重定位推迟到运行程序的时候
装载时重定位程序运行时，共享库模块地址确定，系统对程序中所有的绝对地址进行重定位

优化动态链接性能：
地址无关代码：把指令中需要修改的部分分离出来，和数据部分放一起，内存就不会有多份指令的拷贝了，因为指令都一样
延迟绑定：当函数第一次被用到才进行绑定
