#编译
#1.https://segmentfault.com/a/1190000020325922
#2.https://segmentfault.com/a/1190000021942612?utm_source

    gcc -c main.c ==== 编译不链接，生成.o目标文件
    gcc -E main.c ==== 预处理 
    gcc -S main.c ==== 只编译不汇编
    gcc -g main.c -o main_d ==== 可进行gdb调试
    gcc -Dname='xinzhu' === 定义宏 define name 'xinzhu'

    gcc main.c -o main -I../path
    gcc main.c -o main -I../path -L../path

    gcc -I [大写字母i]寻找头文件目录 /usr/local/include 
    gcc -L [大写字母l]寻找库文件 /usr/local/lib
    gcc -l word [小写字母l], 寻找动态链接库文件libword.so
    
#Linux下的静态库.a结尾(Winodws下为.lib)
   创建.o目标文件
    gcc -c test.c -o libtest.o
    #创建libtest.a静态库
    ar rcs libtest.a libtest.o
    #链接静态库
    gcc -o test main.c -ltest

#Linux下的动态库.so结尾或.so.y结尾，其中y代表版本号(Windows下为.dll)，而且，Linux下的库必须以lib开头，用于系统识别(如：libjpeg.a libsdl.so)
    # 使用位置无关代码创建目标文件
    gcc -c -fPIC test.c -o test.o
    # 创建共享库libtest.so
    gcc -shared -o libtest.so test.o
    # 链接静态库
    gcc -o test main.c -ltest
 
#静态库必要的目标代码的是在对程序编译的时候被加入到程序中,而运行时不再需要.a的库了。
而动态库，则是在运行时转载。所以，动态链接的可执行代码比静态链接的可执行代码小的多.
静态库是牺牲了空间效率，换取了时间效率.
共享库是牺牲了时间效率换取了空间效率
linux储存位置：静态库的保存位置和共享库是一样的 /lib（系统启动时需要的库，执行shell需要的库，是系统最关键的库） /usr/lib（开发时用到的库）

加载时间不同：静态库在静态链接时使用，每个程序都有一份 共享库在动态链接时使用。
所以使用静态库的缺点是：
1.在多进程操作系统下浪费内存和磁盘空间。
2.修改静态库后，需要重新链接。
3.共享库就是为了解决静态库的这些缺点：节省内存，减少物理页面的换入换出，增加cpu的缓存命中率。

动态库分为显式调用和隐式调用
1.显示调用
2.隐式调用

生成静态库和共享库的命令：
ar:
选项前可以有'-'字符，也可以没有
r：在库中插入模块(替换)。
c：创建一个库。不管库是否存在，都将创建。
v：该选项用来显示执行操作选项的附加信息

静态库：
首先将源文件编译成目标文件：gcc –c a.c b.c
生成静态库：ar crv libstatic.a a.o b.o

共享库：
同静态库一样编译成目标文件：gcc –c a.c b.c
生成共享库：gcc –fPIC –shared –o libshared.so a.o b.o

-shared 产生共享对象
-fPIC 使用地址无关技术（如果没有这命令选项，产生的将是装载时重定位对象）

/proc/pid/maps
内存段虚拟地址执行权限进程地址里偏移量映射文件的主设备号和次设备号（cat /proc/devices）映像文件路径

readeld –l Lib.so
判断一个DSO是否为PIC的办法
readelf –d foo.so | greap TEXTREL（重定位表地址）
有信息就表示有重定位表，那么就不是PIC

库文件：一组编译好的函数集合
ld-2.6.so 动态链接器
linux命名共享库的规则：libname.so.x.y.z
1. 前缀"lib"+ 自定义名字"name"+ 后缀"so"
2. x：主版本号 y：次版本号 z：发布版本号
3. glibc不遵守规则，使用 libc-x.y.z.so

ldconfig更新共享库
静态库使用静态链接
共享库使用动态链接

动态链接：
就是把链接的过程推迟到了运行的时候
在链接的时候，共享库也作为链接的输入文件之一，
符号解析的时候，把源文件中重定位推迟到运行程序的时候
装载时重定位程序运行时，共享库模块地址确定，系统对程序中所有的绝对地址进行重定位

优化动态链接性能：
地址无关代码：把指令中需要修改的部分分离出来，和数据部分放一起，内存就不会有多份指令的拷贝了，因为指令都一样
延迟绑定：当函数第一次被用到才进行绑定
